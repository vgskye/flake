# Do not modify this file!  It was generated by ‘nixos-generate-config’
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{
  config,
  lib,
  pkgs,
  modulesPath,
  ...
}: {
  imports = [
    ../mobile-nixos/modules/quirks/qualcomm/sdm845-modem.nix
    ../mobile-nixos/modules/quirks/audio.nix
    ../mobile-nixos/modules/kernel-config.nix
    ../mobile-nixos/devices/families/mainline-chromeos-sc7180/sound.nix
  ];

  boot.loader.grub.enable = false;
  boot.loader.generic-extlinux-compatible = {
    enable = true;
  };

  nixpkgs.config.allowUnfree = true;

  # boot.kernelPackages =
  # let
  #   kernel = pkgs.callPackage ../mobile-nixos/devices/families/mainline-chromeos-sc7180/kernel {};
  #   # lie to make the assertion not die
  #   kernelLies = kernel.overrideAttrs (old: {
  #     features = [];
  #   });
  #   # kernel = pkgs.callPackage ./kernel.nix {};
  # in pkgs.linuxPackagesFor kernelLies;
  boot.kernelPackages = pkgs.linuxPackagesFor (pkgs.linux_6_8.override {
    argsOverride = {
      defconfig = "sc7180_defconfig";
    };
  });

  networking.wireless.enable = lib.mkDefault true;
  networking.wireless.userControlled.enable = lib.mkDefault true;

  # The default's assuming incorrectly for a few of these, so specify our own
  boot.initrd.includeDefaultModules = false;

  boot.initrd.availableKernelModules = [
    # Default had some SATA stuff here. We do not have SATA.
    # Same but NVMe

    # Standard SCSI stuff.
    "sd_mod"
    "sr_mod"

    # SD cards and internal eMMC drives.
    "mmc_block"

    # USB input support, trimmed down since we only really need hammer.
    "ehci_hcd"
    "ohci_hcd"
    "xhci_hcd"
    "usbhid"
    "hid_generic"
    "hid_google_hammer"

    # A whole bunch of CrOS EC drivers
    "extcon_usbc_cros_ec"
    "i2c_cros_ec_tunnel"
    "cros_ec_lid_angle"
    "cros_ec_sensors_core"
    "cros_ec_sensors"
    "cros_ec_keyb"
    "cros_ec_dev"
    "cros_ec_chardev"
    "cros_ec_i2c"
    "cros_ec"
    "cros_ec_rpmsg"
    "cros_ec_sensorhub"
    "cros_ec_spi"
    "cros_ec_sysfs"
    "cros_ec_typec"
    "cros_ec_vbc"
    "cros_usbpd_notify"
    "cros_usbpd_charger"
    "pwm_cros_ec"
    "cros_ec_regulator"
    "rtc_cros_ec"
    "snd_soc_cros_ec_codec"

    # from nixos-mobile
    "sbs-battery"
    "sbs-charger"
    "sbs-manager"
  ];

  boot.kernelPatches = [
    {
      name = "sc7180-defconfig";
      patch = ./defconfig.patch;
    }
    {
      name = "sc7180-dsi";
      patch = pkgs.fetchpatch {
        url = "https://github.com/torvalds/linux/commit/75ee2ff7b8427645f294098d9c6f005399f4ce94.patch";
        hash = "sha256-VJnyQfwwjnfzMPZkfSVd99vKxGUvYNn1qwC3Kf6crJA=";
      };
      # extraStructuredConfig = import ./qualcomm_cros.nix pkgs;
    }
  ];

  mobile.kernel.structuredConfig = [
    (helpers:
      with helpers; {
        MODULES = yes;
        I2C_SMBUS = module;
        BATTERY_SBS = module;
        CHARGER_SBS = module;
        MANAGER_SBS = module;
      })
    # copied from pmOS
    # do they work? I don't fucking know
    (helpers:
      with helpers; {
        # okay this one isn't pmOS I just wanted some insight
        I2C_CHARDEV = yes;

        # Cr50 TPM
        TCG_TIS_SPI = yes;
        TCG_TIS_SPI_CR50 = yes;

        # cameras
        VIDEO_V4L2_SUBDEV_API = yes;
        VIDEO_QCOM_CAMSS = module;
        VIDEO_IMX219 = module;
        VIDEO_OV5640 = module;
        VIDEO_OV5645 = module;
      })
  ];

  security.tpm2.enable = true;

  hardware.firmware = [
    pkgs.chromeos-sc7180-unredistributable-firmware
    (pkgs.callPackage ../mobile-nixos/devices/families/mainline-chromeos-sc7180/firmware {})
  ];

  # NixOS, by default, tries to "smartly" figure out
  # which firmwares are needed in initrd.
  # In this case, it selects nothing.
  # That is... wrong, and we need to supply them.
  # However, /lib/firmware is still taken by the empty directory.
  # So we put them in /hacky-fw-links, and tell the kernel.
  boot.initrd.extraFiles = let
    firmwares = [
      "qcom/venus-5.4/venus.mdt"
      "qcom/a630_sqe.fw"
      "qca/crbtfw32.tlv"
      "qca/crnv32.bin"
      "regulatory.db"
      "regulatory.db.p7s"
    ];
  in
    builtins.listToAttrs
    (builtins.map (
        fw: {
          name = "/hacky-fw-links/${fw}.xz";
          value = {
            source =
              pkgs.runCommand "hacky-fw-links-${fw}" {
                src = "${config.hardware.firmware}/lib/firmware/${fw}.xz";
                preferLocalBuild = true;
              } ''
                cat $src > $out
              '';
          };
        }
      )
      firmwares);

  hardware.sensor.iio.enable = true;

  system.build.fsImage = pkgs.callPackage (modulesPath + "/../lib/make-ext4-fs.nix") {
    storePaths = config.system.build.toplevel;
    populateImageCommands = "${config.boot.loader.generic-extlinux-compatible.populateCmd} -c ${config.system.build.toplevel} -d ./files/boot";
    volumeLabel = "thorley";
  };

  hardware.deviceTree = {
    enable = true;
    filter = "*sc7180*.dtb";
    name = "qcom/sc7180-trogdor-wormdingler-rev1-boe.dtb";
  };

  boot.swraid.enable = false;

  # Ensure orientation match with keyboard.
  services.udev.extraHwdb = lib.mkBefore ''
    sensor:accel-display:modalias:platform:cros-ec-accel:*
      ACCEL_MOUNT_MATRIX=0, 1, 0; -1, 0, 0; 0, 0, -1
  '';

  boot.kernelParams = lib.mkBefore [
    "console=ttyMSM0,115200n8"

    # Tell the kernel to look for firmwares in our links
    "firmware_class.path=/hacky-fw-links"
  ];

  systemd.services."serial-getty@ttyMSM0" = {
    enable = true;
    wantedBy = ["multi-user.target"];
  };

  mobile.quirks.qualcomm.sc7180-modem.enable = true;
  nixpkgs.overlays = [
    (final: super: {
      chromeos-sc7180-unredistributable-firmware = final.callPackage ../mobile-nixos/devices/families/mainline-chromeos-sc7180/firmware/non-redistributable.nix {};
    })
    (import ../mobile-nixos/overlay/overlay.nix)
  ];

  fileSystems."/" = {
    device = "/dev/disk/by-label/thorley";
    fsType = "ext4";
  };

  networking.useDHCP = lib.mkDefault true;

  nixpkgs.hostPlatform = "aarch64-linux";
}
